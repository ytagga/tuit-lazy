<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>../tuit/list.lua</title>
	<link rel="stylesheet" type="text/css" href="default.css" />
</head>
<body>


<h1>tuit.list</h1>

<h2>NAME</h2>

<p>tuit.list - list library</p>

<h2>SYNOPSIS</h2>

<pre><code> m = require "tuit.list"
 r = m.equal({1, 2, {3}}, {1, 2, {3}}) -- true
</code></pre>


<h2>DESCRIPTION</h2>

<p>This module provides linear list functions.
Some have a similar one in tuit.array' module,
but the order of the arguments may be different.</p>


<h3>constructors</h3>

<ul>
    <li><p><code>m.list(obj1, obj2, ...)</code> - returns a newly allocated list of its arguments.</p></li>
    <li><p><code>m.list_copy(list)</code> - copies the spine of the argument.</p></li>
    <li><p><code>m.unfold(null, kar, kdr, seed, [head])</code> - is a generic recursive
constructor.  If <code>kar</code> never returns <code>nil</code>, this is equivalent to
the following funtion:</p>

<p>   function m.unfold(null, kar, kdr, seed, head)</p>
<pre><code> if null(seed) then
   return head
 else
   table.insert(head, kar(seed))
   return m.unfold(null, kar, kdr, kdr(seed), head)
 end
</code></pre>
<p>   end</p></li>
</ul>

<p>The actual implementation ends the list if <code>null(seed)</code> is true
or if <code>kar(seed)</code> returns <code>nil</code>. If <code>head</code> is omitted, <code>{}</code> is used
instead.</p>

<h3><code>fold</code> and other acumulator functions</h3>

<ul>
    <li><code>m.fold_left(proc, init. lst1, ...)</code> - iterates function <code>proc</code> over an acumulator value and the elements of lists <code>lst1</code>, ... from left to right, starting with an acumulator value <code>init</code>. If <code>lst</code> is empty, it returns <code>init</code>.</li>
    <li><code>m.fold_right(proc, init. lst1, ...)</code> - iterates function <code>proc</code> over an acumulator value and the elements of list <code>lst1</code>, ... from right to left, starting with an acumulator value <code>init</code>. If <code>lst</code> is empty, it returns <code>init</code>.</li>
    <li><code>m.reduce_left(proc, lst)</code>  - iterates function <code>proc</code> over an acumulator value and the elements of list <code>lst</code> from left to right, starting with the first element of <code>lst</code>.</li>
    <li><code>m.reduce_right(proc, lst)</code> - iterates function <code>proc</code> over an acumulator value and the elements of list <code>lst</code> from right to left, starting with the last element of <code>lst</code>.</li>
</ul>

<h3><code>map</code>, <code>filter</code>, and selectors</h3>

<ul>
    <li><p><code>m.map(proc, lst1, lst2, ...)</code> - applies <code>proc</code> element-wise to the elements of the lists in order and returns a list of the results.</p></li>
    <li><p><code>m.filter(pred, lst)</code> - returns a list of the elements of <code>lst</code> that satisfy predicate <code>pred</code>.</p></li>
    <li><p><code>m.each(proc, lst1, ...)</code> - calls procedure <code>proc</code> with the elements of the lists in order.</p></li>
    <li><p><code>m.each_ipair(proc, lst)</code> - calls procedure <code>proc</code> with an index and its value of list <code>lst</code> in order.</p></li>
    <li><p><code>m.each_pair(proc, tab)</code> - calls procedure <code>proc</code> with a key and its value of table <code>tab</code>.</p></li>
    <li><p><code>m.find(pred_or_elt, lst)</code> - returns the index and the value of the first element of list <code>lst</code> that is equivalent to or satisfies the first argument.</p></li>
    <li><p><code>m.take(lst, i)</code> - returns a list of the first <code>i</code> elements of list <code>lst</code>.</p></li>
    <li><p><code>m.drop(lst, i)</code>  - removes the first <code>i</code> elements from list <code>lst</code>.</p></li>
    <li><p><code>m.erase(pred_or_elt, lst)</code> - deletes all the elements in list <code>lst</code> that are equivalent to or satisfy the first argument.</p></li>
    <li><p><code>m.take_while(pred, lst)</code> - returns the longest initial sequence of list <code>lst</code> whose elements all satisfy the predicate <code>pred</code>.</p></li>
    <li><p><code>m.drop_while(pred, lst)</code> - removes the longest initial sequence of list <code>lst</code> whose elements all satisfy the predicate <code>pred</code>.</p></li>
    <li><p><code>m.any(pred, lst1, ...)</code> - returns <code>true</code> if <code>pred</code> returns true on any application, else returns <code>false</code>.</p></li>
    <li><p><code>m.every(pred, lst1, ...)</code> - returns <code>true</code> if <code>pred</code> returns true on every application, else returns <code>false</code>.</p></li>
</ul>

<h3>miscellaneous</h3>

<ul>
    <li><code>m.equal(x, y)</code> - returns <code>true</code> if and only if <code>a</code> and <code>b</code> are recursively
    equivalent.</li>
    <li><code>m.apply(proc, lst)</code> applies procedure <code>proc</code> to a list of arguments <code>lst</code>.</li>
    <li><code>m.count(pred, lst)</code> - returns the number of the elements in <code>lst</code> that satisfy <code>pred</code></li>
    <li><code>m.last(lst)</code> - return the last element of list <code>lst</code>.</li>
    <li>m.first(lst)<code>- returns the first element of list</code>lst`.</li>
    <li><code>m.length(lst)</code> - return the length of list <code>lst</code>.</li>
    <li><code>m.append(lst1, lst2)</code> - appends the elements of list <code>lst2</code> to list <code>lst1</code>.</li>
    <li><code>m.reverse(lst)</code> - reverses the order of list <code>lst</code>.</li>
    <li><code>m.zip(lst1, lst2, ...)</code> - With <code>n</code> lists, it returns a list
    as long as the shortest of these lists,
    each element of which is an <code>n</code>-element list comprised of
    the corresponding elements from the parameter lists.</li>
    <li><code>m.flatten(lst)</code> - flattens list <code>lst</code>.</li>
    <li><code>m.push(lst, x, ..)</code> - treats <code>lst</code> as a stack, by appending <code>x</code>, ... to the end of <code>lst</code>.</li>
    <li><code>m.unshift(lst, x, ...)</code> - prepends <code>x, ... to the front of</code>lst`.</li>
    <li><code>m.pop(lst, [n]) - pops the last</code>n<code>elements of</code>lst` and returns them.
    If <code>n</code> is ommitted, <code>n</code> is assumed to be <code>1</code>.</li>
    <li><code>m.shift(lst, [n])</code> - shifts the first <code>n</code> elements of <code>lst</code> and returns them. If <code>n</code> is ommitted, <code>n</code> is assumed to be <code>1</code>.</li>
    <li><code>m.values_at(lst, i, ...)</code> - returns the values of the elements whose indice are <code>i</code>, ...</li>
</ul>

<h2>AUTHOR</h2>

<p>TAGA Yoshitaka</p>


</body></html>