<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>../tuit/combine.lua</title>
	<link rel="stylesheet" type="text/css" href="default.css" />
</head>
<body>


<h1>tuit.combine</h1>

<h2>NAME</h2>

<p>tuit.combine - functions for functional programming</p>

<h2>SYNOPSIS</h2>

<pre><code> m = require "tuit.combine"
 print(m.fix(function () return m.const(9) end)(3)) -- 9
</code></pre>

<h2>DESCRIPTION</h2>

<p>This module provides utility functions for functional programming.</p>


<h3>high-order functions</h3>

<ul>
    <li><code>m.comp(f1, f2, ..., fn)</code> - composition <br/>
    This function makes a composite function of <code>f1, f2, ..., fn</code>,
    which takes a single argument <code>x</code> and returns <code>f1(f2(...fn(x)))</code>.</li>
    <li><code>m.curry(f, [n])</code> - Currying <br/>
    Given function <code>f</code> of type (X&times;Y&rarr;Z), this function
    make a single argument function of type X&rarr;(Y&rarr;Z).
    <code>m.curry(f, n)</code> applies the Currying <code>n</code> times.</li>
    <li><code>m.part(f, ...)</code> -  partial application <br/>
    This function fixes the first arguments and makes another function of
    smaller arity.</li>
    <li><code>m.neg(pred)</code> - complementation <br/>
    This function makes a negated version of predicative function <code>pred</code>.</li>
    <li><code>m.memoize(f)</code> - memoization <br/>
    This function makes a memoized version of function <code>f</code>.</li>
</ul>

<h3>combinators</h3>

<ul>
    <li><code>m.fix(f)</code> -- fix point combinator <br/>
    This function return a function which computes a fix-point of <code>f</code>.</li>
    <li><code>m.flip(f)</code> - C combinator <br/>
    This function returns a function which takes two arguments in reverse
    order of <code>f</code>.</li>
    <li><code>m.const(x)</code> -  K combinator <br/>
    This function returns a function which always returns <code>x</code>.</li>
</ul>

<h3>utility functions</h3>

<ul>
    <li><code>m.null(x)</code> -  null? <br/>
    This function checks if the argument is <code>nil</code>.</li>
    <li><code>m.id(x)</code> - the identity function <br/>
    This function returns the argument itself.</li>
</ul>

<h3>wrappers of Lua operators</h3>

<ul>
    <li><code>m.add(x, y)</code> - <code>x + y</code></li>
    <li><code>m.sub(x, y)</code> - <code>x - y</code></li>
    <li><code>m.mul(x, y)</code> - <code>x * y</code></li>
    <li><code>m.div(x, y)</code> - <code>x / y</code></li>
    <li><code>m.mod(x, y)</code> - <code>x % y</code></li>
    <li><code>m.pow(x, y)</code> - <code>x ^ y</code></li>
    <li><code>m.unm(x)</code> - <code>- x</code></li>
    <li><code>m.concat(x, y)</code> - <code>x .. y</code></li>
    <li><code>m.len(x)</code> - <code>#x</code></li>
    <li><code>m.eq(x, y)&gt;</code>- <code>x == y</code></li>
    <li><code>m.lt(x, y)</code> - <code>x &lt; y</code></li>
    <li><code>m.le(x, y)</code> - <code>x &lt;= y</code></li>
    <li><code>m.gt(x, y)</code> - <code>x &gt; y</code></li>
    <li><code>m.ge(x, y)</code> - <code>x &gt;= y</code></li>
    <li><code>m.index(x, y)</code> - <code>x[y]</code></li>
    <li><code>m.call(f, ...)</code> - <code>f(...)</code></li>
</ul>

<h2>AUTHOR</h2>

<p>TAGA Yoshitaka</p>


</body></html>